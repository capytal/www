package pages

import (
	"bytes"
	"io"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"log"

	"forge.capytal.company/capytal/www/templates/layouts"

	"forge.capytal.company/loreddev/x/groute/router/rerrors"
	"forge.capytal.company/loreddev/x/groute/router"
	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/extension"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark-meta"
)

type EntryTemplate func([]byte) templ.Component
type EntryListTemplate func(map[string]entry) templ.Component

type Blog struct {
	repo     string
	owner    string
	endpoint string

	md                goldmark.Markdown
	entryTemplate     EntryTemplate
	entryListTemplate EntryListTemplate

	entries map[string]entry
}

type entry struct {
	title    string
	path     string
	summary  string
	contents templ.Component
}

type BlogOptions struct {
	EntryTemplate EntryTemplate
}

func NewBlog(owner, repo, endpoint string, opts ...BlogOptions) (*Blog, error) {
	/*
		opt := BlogOptions{}
		if len(opts) > 0 {
			opt = opts[0]
		}
	*/

	u, err := url.Parse(endpoint)
	if err != nil {
		panic(fmt.Sprintf("Blog Forgejo endpoint is not a valid URL: %v", err))
	}

	md := goldmark.New(
		goldmark.WithExtensions(extension.GFM, meta.Meta),
		goldmark.WithParserOptions(parser.WithAutoHeadingID()),
	)

	blog := &Blog{
		repo:     repo,
		owner:    owner,
		endpoint: u.String(),
		md:       md,
		// entryTemplate: opt.EntryTemplate,
		entryTemplate:     template,
		entryListTemplate: templateList,

		entries: map[string]entry{},
	}

	if err := blog.init(); err != nil {
		return nil, err
	}

	return blog, nil
}

func (p *Blog) Routes() router.Router {
	r := router.NewRouter()

	r.HandleFunc("/{entry...}", func(w http.ResponseWriter, r *http.Request) {
		pv := r.PathValue("entry")
		if pv == "" {
			p.listPosts(w, r)
		} else {
			p.blogEntry(w, r)
		}
	})

	return r
}

func (p *Blog) init() error {
	_, body, rerr := p.get(fmt.Sprintf("/repos/%s/%s/contents/daily-blogs", p.owner, p.repo))
	if rerr != nil {
		return rerr
	}

	log.Printf("Getting files from repository")

	var list []forgejoFile
	err := json.Unmarshal(body, &list)
	if err != nil {
		return errors.Join(errors.New("failed to parse list of entries"), err)
	}

	entries := make(map[string]entry, len(list))
	for _, e := range list {
		log.Printf("Getting entry %s", e.Path)

		_, body, rerr := p.get(fmt.Sprintf("/repos/%s/%s/raw/%s", p.owner, p.repo, e.Path))
		if rerr != nil {
			return rerr
		}

		var buf bytes.Buffer

		ctx := parser.NewContext()

		err := p.md.Convert(body, &buf, parser.WithContext(ctx))
		if err != nil {
			return err
		}

		meta := meta.Get(ctx)

		var title string
		if t, ok := meta["title"]; ok {
			title, ok = t.(string)
			if !ok {
				title = "failed to concat string" // aka Yaml "yes" as bool being fucking annoying
			}
		} else {
			title = fmt.Sprintf("NO TITLE %s", e.Path)
		}

		html, err := io.ReadAll(&buf)
		if err != nil {
			return err
		}

		comp := p.entryTemplate(html)

		entries[e.Path] = entry{
			title:    title,
			path:     e.Path,
			summary:  "no summary",
			contents: comp,
		}
	}

	p.entries = entries

	return nil
}

func (p *Blog) listPosts(w http.ResponseWriter, r *http.Request) {
	err := p.entryListTemplate(p.entries).Render(r.Context(), w)
	if err != nil {
		rerrors.InternalError(err).ServeHTTP(w, r)
	}
}

func (p *Blog) blogEntry(w http.ResponseWriter, r *http.Request) {
	e, ok := p.entries[r.PathValue("entry")]
	if !ok {
		rerrors.NotFound().ServeHTTP(w, r)
		return
	}

	err := e.contents.Render(r.Context(), w)
	if err != nil {
		rerrors.InternalError(errors.New("failed to write response"), err).ServeHTTP(w, r)
		return
	}
}

func (p *Blog) get(endpoint string) (http.Header, []byte, *rerrors.RouteError) {
	u, _ := url.Parse(p.endpoint)
	u.Path = path.Join(u.Path, endpoint)

	r, err := http.Get(u.String())
	if err != nil {
		e := rerrors.InternalError(
			fmt.Errorf("failed to make request to endpoint %s", u.String()),
			err,
		)
		return nil, nil, &e
	}

	body, err := io.ReadAll(r.Body)
	if err != nil {
		e := rerrors.InternalError(
			fmt.Errorf("failed to read response body of request to endpoint %s", u.String()),
			err,
		)
		return nil, nil, &e
	} else if r.StatusCode != http.StatusOK {
		e := rerrors.InternalError(
			fmt.Errorf("request to endpoint %s returned non-200 code %q.\n%s", u.String(), r.Status, string(body)),
		)
		return nil, nil, &e
	}

	return r.Header, body, nil
}

type forgejoFile struct {
	Name          string `json:"name"`
	Path          string `json:"path"`
	Sha           string `json:"sha"`
	LastCommitSha string `json:"last_commit_sha"`
	Type          string `json:"type"`
}

templ template(html []byte) {
	@layouts.Page() {
		<div class="w-100% py-10rem flex justify-center">
			<main class="w-60%">
				@templ.Raw(string(html))
			</main>
		</div>
	}
}

templ templateList(entries map[string]entry) {
	@layouts.Page() {
		<div class="w-100% py-10rem flex justify-center">
			<main class="w-60%">
				<h1>Blog</h1>
				<ul class="list-none">
					for _, e := range entries {
						<li>
							<h2><a href={ templ.SafeURL(path.Join(".", e.path)) }>{ e.title }</a></h2>
							<p>{ e.summary }</p>
						</li>
					}
				</ul>
			</main>
		</div>
	}
}
